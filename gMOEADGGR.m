classdef gMOEADGGR < ALGORITHM
% <multi/many> <real/binary/permutation>
% MOEA/D-GGR (generational)
% delta --- 1 --- The probability of selecting candidates from neighborhood
% p --- 1 --- The parameter p of GNS
% Tm --- 0.1 --- The mating neighborhood size
% Tr --- 0.001 --- The replacement neighborhood size
% 
%   Author: Ruihao Zheng

    methods
        function main(Algorithm,Problem)
            %% Parameter setting
            [delta, p, Tm, Tr] = Algorithm.ParameterSet(1, 1, 0.1, 0.001);

            %% initialization
            % Generate the weight vectors
            [W, Problem.N] = UniformPoint(Problem.N, Problem.M);
            Tm = ceil(Problem.N * Tm);
            Tr = ceil(Problem.N * Tr);
            % Detect the mating neighbors of each solution
            B = pdist2(W, W);
            [~,B] = sort(B, 2);
            Bm = B(:, 1:Tm);
            % Generate random population
            Population = Problem.Initialization();
            % Initialize the reference point
            z = min(Population.objs, [], 1);
            % Dertermine the scalar function
            switch p
                case 1
                    type = 1.2;
                case inf
                    type = 2;
                otherwise
                    type = 7 + min(999, p)*0.001;
            end
            h = (prod(W,2).^(-1/Problem.M));
            % Repair the boundary weight generated by "UniformPoint"
            zero_counter = sum(W<=1e-6, 2);
            [~, I] = max(W, [], 2);
            for i = 1 : Problem.N
                W(i, I(i)) = W(i, I(i)) - zero_counter(i)*1e-6;
            end
            % Add boundary subproblems to the closest non-boundary
            % subproblem's neighborhood (Not available)


            %% Optimization
            while Algorithm.NotTerminated(Population)
                
                % Obtain the mating pool
                MatingPool = zeros(1, 2 * Problem.N);
                for i = 1 : Problem.N
                    % Choose the parents
                    if rand < delta
                        P = Bm(i, randperm(Tm));
                    else
                        P = randperm(Problem.N);
                    end
                    MatingPool(i) = P(1);
                    MatingPool(Problem.N + i) = P(2);
                end
                
                % Generate N offspring
                Offspring = OperatorGAhalf_2(Population(MatingPool));
                
                % Update the reference point
                z = min([z; Offspring.objs]);
                
                % Replacement
                Pt = [Population Offspring];
                objs = Pt.objs;
                % Calculate the subproblem function values  O(N^2)
                g = zeros(size(objs,1), Problem.N);
                for i = 1 : Problem.N
                    g(:, i) = calSubpFitness(type, objs, z, W(i, :)) * h(i);
                end
                % Find the most suitable solution for each subproblem
                [~, I_subp] = min(g, [], 2);
                index_Pt = zeros(Problem.N, 1);
                select_counter = zeros(size(objs,1),1);
                for i = 1 : Problem.N
                    closest = find(I_subp==i & select_counter<Tr);  % a solution is selected at most Tr times.
                    if isempty(closest)
                        % index_Pt(i) = i;  % Pt should not be shuffled since we assume the i-th solution of Pt corresponds to the original solution of i-th subproblem.
                        [~,index_Pt(i)] = min(g(:,i));  % improve the convergence by this greedy method; it is helpful to find the boundary of the concave PF when p=1
                        continue
                    end
                    [~, Ri] = min(g(closest, i));
                    index_Pt(i) = closest(Ri);
                    select_counter(closest(Ri)) = select_counter(closest(Ri)) + 1;
                end
                Population = Pt(index_Pt);
            end
        end
    end
end